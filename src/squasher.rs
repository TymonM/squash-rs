use std::collections::HashSet;
use std::fs;

pub(crate) struct Squasher {
    visited_files: HashSet<String>,
    squashed_content: String,
}

impl Squasher {
    pub fn new() -> Squasher {
        Squasher {
            visited_files: HashSet::new(),
            squashed_content: String::new(),
        }
    }

    pub fn reset(&mut self) {
        self.visited_files.clear();
        self.squashed_content.clear();
    }

    // Squash only .cpp files in the directory
    fn get_sources(&self, dir: fs::ReadDir) -> Vec<fs::DirEntry> {
        dir.filter_map(|entry| {
            let entry = entry.ok()?;
            if let Some(ext) = entry.path().extension() {
                if ext == "cpp" {
                    return Some(entry);
                }
            }
            None
        })
        .collect()
    }

    fn squash_file(&mut self, path: std::path::PathBuf) {
        if !path.exists() {
            eprintln!("File not found: {}", path.display());
            return;
        }

        let filepath = path.to_str().unwrap();
        if self.visited_files.contains(filepath) {
            self.squashed_content.push_str(&format!(
                "/* -- SKIPPING DUPLICATE {} -- */\n",
                path.file_name().unwrap().to_str().unwrap()
            ));
            return; // already visited
        }

        self.visited_files.insert(filepath.to_string());
        self.squashed_content.push_str(&format!(
            "/* -- {} -- */\n",
            path.file_name().unwrap().to_str().unwrap()
        ));

        let content = fs::read_to_string(&path).unwrap();
        for line in content.lines() {
            if line.starts_with("#include") {
                let include_path = line.split_whitespace().nth(1).unwrap();
                if include_path.starts_with('<') && include_path.ends_with('>') {
                    // don't process standard library includes
                    self.squashed_content.push_str(line);
                    self.squashed_content.push('\n');
                    continue;
                }
                let include_path = include_path.trim_matches('"');
                if !self.visited_files.contains(include_path) {
                    let include_path = path.parent().unwrap().join(include_path);
                    self.squash_file(include_path);
                }
                continue;
            }
            self.squashed_content.push_str(line);
            self.squashed_content.push('\n');
        }

        self.squashed_content.push_str(&format!(
            "/* -- END OF {} -- */\n",
            path.file_name().unwrap().to_str().unwrap()
        ));
    }

    pub fn squash_directory(&mut self, directory: &str) {
        let dir = fs::read_dir(directory).unwrap();
        let sources = self.get_sources(dir);
        for entry in sources {
            self.squash_file(entry.path());
        }
    }

    pub fn write_file(&self, path: &std::path::Path) {
        // Write an autogenerated comment and then the squashed content
        let header = format!(
            "// generated by squash on {}\n// https://github.com/TymonM/squash\n\n",
            chrono::Local::now().format("%Y-%m-%d %H:%M:%S")
        );
        let mut output = header;
        output.push_str(&self.squashed_content);
        fs::write(path, output).expect(&format!("Unable to write file {}", path.display()));
    }
}
